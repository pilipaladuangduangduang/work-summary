# -*- coding: utf-8 -*-


int float fraction（分数） decimal（高精度类型） complex（复数）


索引从左到右，从0开始
索引从右到左，从-1开始

不需要关心字符串/列表的长度：
    取字符串/列表最后一个字符 xxx[-1]
    取字符串/列表倒数第二个字符 xxx[-2]
    取字符串/列表最后三个字符 xxx[-3:]

 +---+---+---+---+---+---+
 | P | y | t | h | o | n |
 +---+---+---+---+---+---+
   0   1   2   3   4   5   
  -6  -5  -4  -3  -2  -1

str[2:5] = 'abc'  # 字符串不可变，所以这样会报错
list[2:5] = ['a', 'b', 'c']  # 这样子完全OK
list[2:5] = []  # 移除3个元素
 
 
[1, 2] + [3, 4] = [1, 2, 3, 4]


# 斐波那契数列
def fibonacci():
    a, b = 0, 1
    while True:
        yield b
        a, b = b, a+b

		
-3**2 = -9  # 因为 ** 的优先级比 - 高，所以想求负数的平方需要加括号 (-3)**2


给函数参数设置默认值时，默认值不要指向可变的（列表、变量等）


*args 接收一个元组 **kvargs 接收一个字典


函数会有 __doc__ 属性，用于存储该函数的注释


《Function annotations的用法》
https://stackoverflow.com/questions/3038033/what-are-good-uses-for-python3s-function-annotations
https://mozillazg.github.io/2016/01/python-function-argument-type-check-base-on-function-annotations.html
# 可以用作参数类型检查，返回值类型检查
def f(ham: str, eggs: str = 'eggs') -> str:
    print("Annotations:", f.__annotations__)
    print("Arguments:", ham, eggs)
    return ham + ' and ' + eggs

	
多层for循环的列表推导式：
	vec = [[0], [1, 2, 3], [4, 5, 6], [7, 8, 9]]
	arr = [num for elem in vec for num in elem] 等同如下代码：
	arr = []
	for elem in vec:
		for num in elem:
			arr.append(num)


序列无法根据根据索引删除元素，但是 del 操作符可以：
	del list[3] # 删除索引是3的元素
	del list[3:5] # 删除索引3和4的元素
	del list[:] # 清空列表
	del list  # 注意这里是删除 list 这个变量
	del dict['key'] # 也可以删除字典的 key


{1, 2, 3} 可以表示为一个 set ，但是 {} 不行，空 {} 表示的是字典
set 也是可以推导的
a = {a for a in '10086'} # {'6', '1', '0', '8'}
b = {b for b in '12580'} # {'1', '0', '8', '5', '2'}
a - b # 差集：a有，b没有的 {'6'}
b - a # 差集：b有，a没有的 {'5', '2'}
a | b # 并集：{'1', '6', '0', '8', '5', '2'}
a & b # 交集：{'1', '0', '8'}
a ^ b # 对称差集：相当于(a | b) - (a & b) {'2', '5', '6'}
a + b # 报错，set 不支持 + 操作


一些常用的 for 循环技巧：
	1、遍历字典的 key value 值：
	for k, v in dict.items(): # 需要用到字典的 items() 函数
		print(k, v)
	2、遍历列表需要知道当前列表元素的索引值:
	for idx, val in enumerate(list): # 需要用到 enumerate() 函数
		print(idx, val)
	3、同时遍历两个列表：
	for x, y in zip(xs, ys): # 需要用到 zip() 函数
		print(x, y)


序列类型的比较，总是逐个的比较，直到不相等的时候就返回结果：
	(1, 2, 3, 4) < (1, 2, 4) # True
	[1, 2, 3, 4] < [1, 2, 4] # True
	'1234' < '124' # True


python 命令行执行脚本并传参：
    python just_main.py 233

	import sys
	if __name__ == '__main__':
		sys.argv    # 所有参数列表，[just_main.py, 233]
		sys.argv[0] # 第一个参数永远是脚本名字，just_main.py
		sys.argv[1] # 这个才是你想传入的第一个参数，233

		
python 中 __pycache__ 目录：
	《What is __pycache__?》https://stackoverflow.com/questions/16869024
	《Python什么情况下会生成pyc文件？》https://www.zhihu.com/question/30296617


python 中 package 中的 __init__.py 文件：
	《Python：__init__.py 详解》http://blog.yongli1992.com/2015/02/14/python-init-py/
	《What is __init__.py for?》https://stackoverflow.com/questions/448271
	《导入模块的几种姿势》http://codingpy.com/article/python-import-101/
	《__all__的作用》https://stackoverflow.com/questions/44834


import json
json.loads(xxx) # str -> dict
json.load(xxx) # file 中的 str -> dict

json.dumps(xxx) # dict -> str
json.dump(xxx) # dict -> str 并写入 file

loads dumps 中的 s 就是 str 的意思
load loads 的 json 字符串不能用单引号，要用双引号


# 这里只返回2，因为 finally 块中包含 return，则返回值就使用 finally 块中的
# 如果 finally 块中不包含 return ，则返回值就是用 try 块或 except 块中的
try:
	if random.randint(0, 1):
		raise
	return 0
except:
	return 1
finally:
	return 2
	

python 中 nonlocal 和 global
	《什么是非局部语句？》http://codingpy.com/article/what-is-nonlocal-statement-in-python
	《Python nonlocal statement》https://stackoverflow.com/questions/1261875

	
python 中 yeild 语句：
	《What does the “yield” keyword do?》https://stackoverflow.com/questions/231767
